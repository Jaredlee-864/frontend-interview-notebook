## 1. 原型/构造函数/实例
  - 原型（prototype）：一个简单的对象，**用于实现对象的属性继承**。简单来说，可以理解为对象的爹。在 Firefox 和 Chrome 中，每个`Javascript` 对象中都包含一个 `__proto__` 属性指向它爹（该对象的原型），可通过 `obj.__proto__` 来访问
  - 构造函数(constructor): 可以通过 `new` 关键字来**新建一个对象**的函数
  - 实例：通过构造函数和 `new` 关键字创建出来的对象，叫实例。**实例通过 `__proto__` 指向原型，通过 `constructor` 指向构造函数**
  - 总结为一句话就是 `obj.__proto__ = obj.contructor.prototype`。即实例的 `__proto__` 属性，指向其构造函数的 `prototype` 属性，两者是相等的，都为原型

## 2. 原型链
> 原型链是由原型对象构成的。每个实例对象都有 **__proto__** 属性，指向了创建该对象的构造函数的原型，**__proto__** 将对象连接起来组成了原型链。是一个用来 **实现继承和共享属性** 的有限的对象链。

- **属性查找机制**：当查找对象的属性时，如果实例对象的自身不存在该属性，就会沿着原型链往上一级查找，找到时输出，找不到则继续沿着原型链向上查找，直至最顶层的原型对象 `Object.prototype`, 如果还是没找到，则输出 `undifined`

- **属性修改机制**：只会修改实例对象本身的属性，如果不存在，则创建新的属性。如果需要修改原型上的属性，则可以用 `obj.prototype.x = 2`; 不过这样会造成所有继承于该对象的实例的属性发生改变

## 3. 执行上下文（EC：Execute Context）
> 执行上下文可以简单的理解为一个对象：

- 它包括三个部分
  1. 变量对象（VO: Virable Object）
  2. 作用域链（词法作用域）
  3. `this` 指向

- 它的类型有：
  1. 全局执行上下文（通常简称为 ECG）
  2. 函数执行上下文（通常简称为 ECF）
  3. `eval` 执行上下文

- 代码执行过程
  - 创建全局执行上下文(Global EC)
  - 全局执行上下文(caller) **自上而下** 执行。遇到函数时，函数执行上下文（callee）被`push`到执行栈的顶层
  - 函数执行上下文被激活（即函数调用时），成为 active EC，开始执行函数中的代码，caller 被挂起
  - 函数执行完成后，callee 被 `pop` 移出执行栈，控制权交还全局执行上下文（caller），继续执行
### 变量对象（VO）

> 变量对象是执行上下文中的一部分，可以抽象成一种 **数据作用域**。简单的理解，VO就是一个对象，该对象存储着执行上下文中的 **变量和函数声明（不包含函数表达式）**

> 活动对象（AO：Active Object）: 当变量对象所处的上下文为 Active EC时，成为活动对象

### 作用域

> 执行上下文中还包含了作用域链。作用域，可以理解为执行上下文当中的 **变量和声明的作用范围**。可分为 **块级作用域** 和 **函数作用域**

> - 特性：

> - 声明提前（作用域提升）：一个声明在函数体内都是可见的，函数优先于变量

> - 非匿名自执行函数，函数变量为 **只读** 状态，无法修改 // TODO:

> ```js
> let foo = function() { console.log(1) };
> (function foo() {
>   foo = 10  // 由于foo在函数中只为可读，因此赋值无效
>   console.log(foo)}
> ()) 
> // 结果打印：  ƒ foo() { foo = 10 ; console.log(foo) }
> ```

### 作用域链

我们可以在执行上下文中访问到自身父级甚至全局的变量，这便是作用域的功劳。作用域链可以理解为一组对象列表，包含 **父级和自身的变量对象**，因此我们便能通过作用域链访问到父级里声明的变量和函数

- 由两部分组成
  - `[[scope]]`属性：指向父级变量对象和作用域链，也就是包含了父级的`[[scope]]` 和 `AO`
  - AO: 自身的活动对象

如此，`[[scope]]`包含`[[scope]]`，便自上而下形成了一条作用域链。

## 闭包(Closure)

函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包。通俗点说就是，可以在另外一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。

闭包的本质：函数在执行的时候会被push到一个执行栈上，当函数执行完毕时，会从栈上移除。**但是堆上的作用域成员因为被外部引用而不能释放**，因此内部函数依然可以访问外部函数的成员

## script 引入方式

- html 静态`<script>`标签引入
- js 动态插入`<script>`
- `<script defer>`: 延迟加载，元素解析完成后执行
- `<script async>`: 异步加载，但执行时会阻塞元素渲染

## Set/weakSet/Map/weakMap
- Set
  - 是一种叫做集合的数据结构
  - 成员唯一、无序且不重复
  - 允许存储任意类型的唯一值，无论是原始类型还是引用引用类型
  - 可以遍历，方法有 `add`, `has`, `delete`, `clear`

- WeakSet
  - 拥有 Set 的特性，但是成员都是对象
  - 而且对象都是弱引用，可以被垃圾回收机制回收，可以用来保存 `DOM` 节点，不容易造成内存泄漏
  - 不能遍历，方法有`add`, `delete`, `has`

- Map
  - 是一种类似于数据字典的数据结构，本质上是键值对的集合。相对于对象 Object 的键名只能是 `String` 或者 `Symbol` 来说，Map 的键值可以是任何值，不会被转换
  - 可以遍历，可以跟各种数据格式转换（转数组，转对象）
  - 操作方法有：`set`, `get`, `has`, `delete`, `clear`

- WeakMap
  - 只接受对象作为键名（`null` 除外），不接受其他类型的值作为键名
  - 键名是弱引用，键名所指向的对象可以被垃圾回收机制回收，回收过后键名是无效的
  - 不能遍历，方法有 `set`, `get`, `has`, `delete`

- Set 和 Map 的遍历方法有 `keys`, `values`, `entries`, `forEach`
