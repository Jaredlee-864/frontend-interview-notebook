## 1. 原型/构造函数/实例
  - 原型（prototype）：一个简单的对象，**用于实现对象的属性继承**。简单来说，可以理解为对象的爹。在 Firefox 和 Chrome 中，每个`Javascript` 对象中都包含一个 `__proto__` 属性指向它爹（该对象的原型），可通过 `obj.__proto__` 来访问
  - 构造函数(constructor): 可以通过 `new` 关键字来**新建一个对象**的函数
  - 实例：通过构造函数和 `new` 关键字创建出来的对象，叫实例。**实例通过 `__proto__` 指向原型，通过 `constructor` 指向构造函数**
  - 总结为一句话就是 `obj.__proto__ = obj.contructor.prototype`。即实例的 `__proto__` 属性，指向其构造函数的 `prototype` 属性，两者是相等的，都为原型

## 2. 原型链
> 原型链是由原型对象构成的。每个对象都有 **__proto__** 属性，指向了创建该对象的构造函数的原型，**__proto__** 将对象连接起来组成了原型链。是一个用来 **实现继承和共享属性** 的有限的对象链。

- **属性查找机制**：当查找对象的属性时，如果实例对象的自身不存在该属性，就会沿着原型链往上一级查找，找到时输出，找不到则继续沿着原型链向上查找，直至最顶层的原型对象 `Object.prototype`, 如果还是没找到，则输出 `undifined`

- **属性修改机制**：只会修改实例对象本身的属性，如果不存在，则创建新的属性。如果需要修改原型上的属性，则可以用 `obj.prototype.x = 2`; 不过这样会造成所有继承于该对象的实例的属性发生改变

## 3. 执行上下文（EC：Execute Context）
> 执行上下文可以简单的理解为一个对象：

- 它包括三个部分
  1. 变量对象（VO: Virable Object）
  2. 作用域链（词法作用域）
  3. `this` 指向

- 它的类型有：
  1. 全局执行上下文（通常简称为 ECG）
  2. 函数执行上下文（通常简称为 ECF）
  3. `eval` 执行上下文

- 代码执行过程
  - 创建全局执行上下文(Global EC)
  - 全局执行上下文(caller) **自上而下** 执行。遇到函数时，函数执行上下文（callee）被`push`到执行栈的顶层
  - 函数执行上下文被激活（即函数调用时），成为 active EC，开始执行函数中的代码，caller 被挂起
  - 函数执行完成后，callee 被 `pop` 移出执行栈，控制权交还全局执行上下文（caller），继续执行
- 