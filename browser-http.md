### 从输入url到展示的过程
  1. 根据缓存策略查询浏览器本地是否有缓存，有缓存请求缓存，没有缓存的情况下进行一下步骤
  2. DNS解析，解析出域名对应的IP地址
  3. 建立TCP连接，三次握手
  4. 发送请求，分析url，设置请求报文（头，体）
  5. 服务器返回请求的数据
  6. 浏览器根据返回的数据
     1. HTML parser --> DOM Tree。解析 HTML 结构，构建成 AST DOM 树
        - 标记化算法，进行元素状态的标记
        - dom 树构建
     2. CSS parser --> Style Tree。解析 CSS， 构建 AST STYLE 样式树
        - 解析css代码，生成样式树
     3. attachment --> Render Tree。
        - 结合 dom 树 和 style 树，生成渲染树
     4. layout 布局
     5. GPU painting：像素绘制页面

### Http 1.0 和 Http 1.1 和 Http 2 的区别

- 连接方面的区别：http 1.0 默认使用非持久链接，http 1.1 默认使用持久链接(Connection： keep-alive)。http 1.1 通过使用持久连接来使多个 http 请求复用一个 TCP 连接，以此来避免使用非持久连接每次都需要建立连接时延长的问题
- 资源请求方面：在 http 1.0 中，存在一些浪费带宽的现象。例如客户端只是需要某个对象的一部分，而服务器却将整个对象发送，并且还不支持断点续传功能，http 1.1 在请求头中引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自有的选择以便于充分利用带宽和链接
- 缓存方面的区别：在 http 1.0 中主要使用 header 里的 If-Modified-Since, Expires 来作为缓存判断的标准，http 1.1 则引入了更多的缓存控制策略：Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头控制缓存策略
- http 1.1 中还新增了 host 字段，用来指定服务器的域名。http 1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此请求消息中的 URL 并没有传递主机名(hostname)。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟服务器。因此有了 host 字段，就可以将请求发往同一台服务器的不同网站。
- http 1.1 相对于 http 1.0 还新增了许多方法，如 PUT, DELETE, HEAD, OPTIONS 等

- http2.0 和 http 1.x 的区别
  - 新的二进制格式(Binary Format)。Http 1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。二进制不同，只认 0 和 1 的组合。
  - 多路复用(MultiPlexing)，即连接共享，即每一个 request 都是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以多个 request，每个链接的 request 可以随机的混杂在一器，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面
  - header 压缩。
  - 服务端推送（server push）


### Http 缓存机制

- http 1.0 和 http 1.1 缓存的区别
  - http 1.0 使用 Expires 头标记缓存时间
  - http 1.1 使用 cache-control 头标记缓存机制，根据不同的属性值定义所需的缓存机制

- Cache-Control 属性值
  - no-store 不缓存，每次发送请求到服务器获取内容，服务器返回全部内容
  - max-age = 1000000 标记过期时间。在该时间内都不会向服务器发起请求，过期后发送请求请求内容并更新过期时间
  - private 私人缓存，即只允许客户端缓存
  - public 公开缓存，客户端和服务器（shared cache -> 中间服务器）都可以缓存
  - no-cache 缓存但是需要重新校验，如果服务器返回校验规则。使用缓存前需要向服务器发送请求校验文件是否有改变，若改变了，服务器返回(200状态码)最新内容并在请求头中标明最新校验信息；如果没改变，服务器返回 304 状态码，报文中只包含头部信息，客户端使用缓存。
  - must-revalidate 必须重新校验

- 校验规则
  - Last-Modified/If-Modified-Since
    - 如果服务器返回的报文中包含 `Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT` 信息
    - 客户端在发送请求报文是，会包含 `If-Modified-Since/If-Unmodified-Since: Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT` 信息
    - 服务端会对比 Last-Modified 和 If-Modified-Since/If-Unmodified-Since 信息，如果服务端的时间在之后，接口返回 200，返回最新内容，包括最新的 Last-Modified; 如果是之前或者相等，表示没有修改，返回 304 状态码，报文中只包含头部信息，客户端使用缓存。

  - ETag/If-None-Match
    - `ETag: W/"<etag_value>"` W/ 表示使用弱校验器(Weak Validator)(待探索...)。etag_value 通常来说可以使用 内容的哈希、上次修改时间戳的哈希或仅使用修订号等等。
    - 如果服务器返回的报文中包含 `ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"` 或者 `ETag: W/"0815"` 信息
    - 客户端在发送请求报文是，会包含 `If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"` 信息
    - 服务端会对比匹配 33a64df551425fcc55e4d42a148795d9f25f89d4 如果匹配到，表示没有修改，返回 304 状态码，报文中只包含头部信息，客户端使用缓存。如果没匹配到，接口返回 200，返回最新内容，包括最新的 ETag;
    - 拓展：
      - 哈希算法：
        - 哈希算法是把一个无限的输入集合映射到一个有限的输出集合。所以会产生哈希碰撞。
        - 特点：
          - 相同的输入一定得到相同的输出
          - 不同的输入，大概率得到不同的输出

### 为什么是三次握手和四次挥手
  - 三次握手的原因：其实是四次，只不过在服务器进行握手的时候，同时将 SYN（synchronous） 和 ACK（acknowledgement） 放到一个报文里面传送给客户端了，这样就减少了一次发送报文的时间，提高了效率。
  - 四次挥手的原因：这是因为当客户端向服务端发送 FIN 报文时，只是表示客户端不会向服务端发送数据了。此时服务端会返回一个 ACK 报文给客户端。但是服务端可能还没有传输完数据，需要继续发送数据给客户端，客户端也可以继续接收数据。当服务端确定发送完数据时，向客户端发送 FIN（finish）报文，表示服务端发送完数据，可以关闭链接，客户端返回 ACK 报文后，链接关闭。

### Https 协议
- http 协议存在的安全问题
  - http 报文使用明文的形式发送，会被窃听
  - http 报文可能被第三方截取后修改通信内容，但是接收方却无法感知到内容被修改
  - http 还存在认证问题，第三方可能冒充他人参与通信

- 超文本传输安全协议。
  - https 是基于 http 协议的，不过 https 会使用 TLS（Transfer Layer Security）/SSL(Secure Socket Layer) 对数据加密。使用 TLS/SSL 协议，所有的信息都是加密的，第三方没办法窃听。并且他提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。
  - TLS握手的过程：
    1. 客户端发送协议版本号、支持的加密方法、一个随机数给服务端
    2. 服务端收到后，发送服务端证书、确认加密方法、生成一个随机数给客户端
    3. 客户端确认服务端证书有效后，生成一个新的随机数，并使用服务端证书的公匙对其加密，并且还会提供一个前面所有内容的 hash 值，发送给服务器，供服务器校验
    4. 服务端使用私匙对服务端发来的随机数进行解密。并提供前面所有内容的 hash 值来供客户端检验。
    5. 客户端和服务端根据约定的加密方法，使用前面三个随机数，生成一个对话密匙。以后的对话过程都使用该密匙来加密信息。

  - 实现原理
  - TLS 的握手过程主要用到了三个方法来保证传输的安全。

    首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

    非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

    因此我们可以使用对称加密和非对称加密结合的方式，因为 对称加密 的方式的缺点是无法保证秘钥的安全传输，因此我们可以 非对称加密 的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。

    但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

    为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。


### 跨标签页通讯

- 通过父页面 `window.open()` 和 子页面 `postMessage`

- 设置同域下共享的 `localStorage` 与 监听 window.onstorage
  - 重复写入相同的值无法触发
  - 会受到浏览器隐身模式等的限制

- 设置共享 `cookies` 与不断轮询脏检查 `setInterval`

- 借助服务端或者中间层实现

### 浏览器架构

- 用户界面
- 主进程
- 内核
  - 渲染引擎
  - JS引擎
    - 执行栈
  - 事件触发线程
    - 消息队列
      - 微任务
      - 宏任务
    - 网络异步线程
    - 定时器线程

### 浏览器下的事件循环（Event Loop）

事件循环是指：执行宏任务，当宏任务执行完成后，检查微任务列表，如果有微任务，则执行微任务，微任务执行完后，继续执行宏任务，然后执行微任务，循环往复。

- 微任务：`Promise/ajax`
- 宏任务：`setTimeout/setInterval/setImmediate/script/IO/UI Rendering`

### 重绘与回流

- 重绘：当元素样式改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新绘制，所以 **消耗较小**

- 回流：当元素的尺寸、结构、或者触发某些属性时，浏览器会重新绘制整个页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此消耗较大。会触发回流的操作有：
  - 页面初次渲染
  - 浏览器窗口大小的改变
  - 元素的尺寸、位置、内容发生变化
  - 元素字体大小的改变
  - 添加或删除可见DOM元素
  - 查询某些属性或调用某些方法时：
    - clientWidth\clientHeight\clientTop\clientLeft
    - offsetWidth\offsetHeight\offsetTop\offsetLeft
    - scrollWidth\scrollHeight\scrollTop\scrollLeft
    - getComputedStyle()
    - getBoundingClientRect()
    - scrollTo()

### 存储

- `cookie`：通常用于存储用户身份信息，登录状态等
  - http 请求中自动携带，体积上限为 4k，可自行设置过期事件
- `localStorage` / `SessionStorage` 长久存储 / 窗口关闭删除，体积限制为 4 ~5 M

### V8 引擎
- V8 是一款主流的 JavaScript 执行引擎
- V8 引擎采用即时编译
- V8 内存设限
  - 64位操作系统是 不超过 1.5G
  - 32位操作系统是 不超过 800M
  - 设限原因
    - 为浏览器设计，对于网页应用来说足够用
    - V8垃圾回收机制，决定了设限标准是比较合理的。当垃圾达到1.5G时，采用增量标记算法进行垃圾回收只需要50ms，但是采用非增量标记却需要1s。

### V8的垃圾回收策略

采用分代回收的思想，内存分为 新生代和老生代 空间，针对不同的空间采用不同的 GC 算法。涉及到的算法有：
  - 分代回收
  - 空间复制
  - 标记清除
  - 标记整理
  - 增量标记

- 新生代（32M | 16M）（存活时间较短的对象）
  - 回收过程采用 复制算法 + 标记整理
  - 新生代内存分为两个等大小的空间
  - 使用空间为 From，空闲空间为 To
  - 活动对象存储于 From 空间
  - 标记整理后将活动对象拷贝至 To 空间
  - From 和 To 交换空间完成释放
  - 回收细节
    - 拷贝过程中会出现晋升(晋升就是将新生代对象移动至老生代内存)
    - 一轮 GC 后还存活的新生代需要晋升
    - To 空间使用率超过 25%

- 老生代
  - 主要采用标记清除、标记整理、增量标记算法
  - 使用标记清除完成垃圾空间的回收
  - 当空间不足时，使用标记整理法进行空间优化
  - 整个过程中，使用增量标记（将垃圾回收过程分割成小部分，穿插在程序执行的过程中）进行效率优化

- 新老细节对比
  - 新生代区域垃圾回收使用空间换时间
  - 老生代区域垃圾回收不适合使用复制算法




### 跨域（域名、端口、协议）

- JSONP：利用 `<script>` 标签不受跨域限制的特点，缺点是只能支持 get 请求
- 设置 CORS : Access-Control-Allow-Origin: *
- postMessage
- 代理服务器，本地启动使用的就是代理服务器

### 安全

- XSS攻击：注入恶意代码
  - cookie 设置 httpOnly
  - 转义页面上的输入内容和输出内容
- CSRF：跨站请求伪造，防护：
  - get 不修改数据
  - 不被第三方网站访问到用户的cookie
  - 设置白名单，不被第三方网站访问
  - 请求校验