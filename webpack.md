### 谈谈你对工程化的初步认识？并结合你之前遇到过的问题说出三个以上工程化能够解决的问题或者带来的价值？

工程化就是解决前端在开发过程中遇到的重复性（手动部署、手动发布等）、不规范（每个开发人员的开发习惯不一样）、开发环境对新特性和插件不支持（ES6等新特性）以及依赖后端开发（依赖后端联调）的问题。

解决的问题和带来的价值：
1. 将开发工作中的重复性工作交给机器，提高开发人员的效率
2. 自动对代码进行格式化并检查代码质量，规范开发团队的代码风格，提高代码质量
3. 可以使用 ES6+ 以及其他可以提高开发效率或者对开发友好的工具进行开发，减轻开发人员的开发负担，提高效率
4. 可以自己 mock 后台数据，将前端开发工作和后端解耦，解决依赖后端的问题

### 你认为脚手架处理为我们创建项目结构，还有什么更深层次的意义？

除了创建项目结构外，更多的式为项目提供了规范和约定。可以使开发人员在开发具有共同项目基础的新项目时，降低开发的学习成本，可以快速上手。

### webpack 构建流程主要有哪些环节？如果可以，请尽可能详尽的描述 webpack 打包的整个过程

webpack 构建流程从开始到结束会依次执行以下三个步骤：

1. 初始化流程：从配置文件 和 shell 语句中读取并合并参数，同时初始化需要使用的插件，并配置插件等执行环境所需要的参数
   - 从配置文件 和 shell 中读取并合并配置，默认的配置文件为 webpack.config.js
   - 将合并好的配置拷贝到 options 对象中，并加载用户配置的 plugins
   - 初始化 compiler 对象，complier 继承自 tapable，初始化时定义了很多狗子函数。该对象掌控着 webpack 的声明周期，不执行具体的任务，只是进行一些调度工作
   - 初始化完成后，会调用 compiler 的 run 方法启动编译流程

2. 编译构建流程：从 Entry 出发，找到对应的 module 并调用对应的 loader 去处理文件内容。如果 module 中有依赖的 module，会递归进行以上操作
   - compiler 开始编译
   - make 从入口分析模块及其依赖的模块，创建对应的模块对象
   - build-module 构建模块
  
3. 输出流程：
   - 对编译后的 module 组合成 chunk，把 chunk 再转换成文件，输出到配置的输出目录中

- 注：webpack 在运行过程中，每个阶段都会触发相应的钩子函数，plugin 会监听对应的钩子函数，当所监听的钩子函数触发时，该 plugin 会加入到 webpack 的编译流程，执行 plugin 

### loader 和 plugin 的区别

- loader 主要在 webpack 加载模块的阶段工作，loader 的主要作用是对不同的文件进行编译
- plugin 几乎可以作用于 webpack 流程的任何一个阶段，相对于 loader 来说，拥有更宽的能力范围，可以做很多 loader 无法做到的事情。例如：压缩、复制、格式化文件等

- loader 的开发
  - loader 其实就是一个函数，该函数接收一个 content（被规则匹配到的文件内容）作为入参，函数中对 content 进行处理编译等，然后将处理过后的 content 内容 return 出去。（注：return 的内容必须是 js 代码）

- plugin 的开发
  - plugin 是一个类，内部有一个 apply 方法，webpack 编译工作启动时会自动调用 apply 方法。在 apply 方法中，需要在 compiler 对象的钩子函数注册事件，例如`compiler.hooks.emit.tap("MyPlugin", callback)`，callback 回调函数接收一个 compilation 参数，该参数可以理解为此次打包的上下文，在 callback 函数中对 compilation 对象中的属性（例如：assets ）进行逻辑处理。被注册的事件（MyPlugin）会在 webpack 执行 emit 钩子函数时被调用，执行 callback

### Vite 的优势，以及为什么会比 webpack 快？

- 依旧使用 rollUp 打包。不使用 esbuild 的原因是目前 esbuild 的一些功能还在开发中，特别是 代码分割 和 css处理 方面。
- 生产环境仍需打包：嵌套导入会导致额外的网络往返，在生产环境发布未打包的 ESM 仍然效率低下。
- 优势：启动快，开发体验好

- 为什么快？
  - vite 通过一开始将应用中的模块区分成 **依赖** 和 **源码** 两类，通过不同的方式进行处理，加快了开发服务器启动的时间
  - **依赖**：vite 使用 **esbuild 预构建依赖**。esbuild 使用 Go 编写，比以JavaScript编写的打包器预构建依赖快 10-100 倍
  - **源码**：以 **原生ESM** （浏览器逐渐支持原生ESM）方式提供源码。实际上是让浏览器接管了打包程序的部分工作：vite只需要在浏览器请求源码的时候进行转换并按需求提供源码。根据情境动态导入代码，即只有在当前屏幕上实际使用时才会被处理。